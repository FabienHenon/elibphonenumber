<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module phonenumber_util</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module phonenumber_util</h1>
<ul class="index"><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#convert_alpha_characters_in_number-1">convert_alpha_characters_in_number/1</a></td><td>Converts all alpha characters in a number to their respective digits on
  a keypad, but retains existing formatting.</td></tr>
<tr><td valign="top"><a href="#format-2">format/2</a></td><td>Formats a phone number in the specified format using default rules.</td></tr>
<tr><td valign="top"><a href="#format_by_pattern-3">format_by_pattern/3</a></td><td>TODO.</td></tr>
<tr><td valign="top"><a href="#format_in_original_format-2">format_in_original_format/2</a></td><td>Formats a phone number using the original phone number format that the
  number is parsed from.</td></tr>
<tr><td valign="top"><a href="#format_national_number_with_carrier_code-2">format_national_number_with_carrier_code/2</a></td><td>Formats a phone number in national format for dialing using the carrier as
  specified in the carrier_code.</td></tr>
<tr><td valign="top"><a href="#format_national_number_with_preferred_carrier_code-2">format_national_number_with_preferred_carrier_code/2</a></td><td>Formats a phone number in national format for dialing using the carrier as  
specified in the preferred_domestic_carrier_code field of the PhoneNumber  
object passed in.</td></tr>
<tr><td valign="top"><a href="#format_number_for_mobile_dialing-3">format_number_for_mobile_dialing/3</a></td><td>Returns a number formatted in such a way that it can be dialed from a
  mobile phone in a specific region.</td></tr>
<tr><td valign="top"><a href="#format_out_of_country_calling_number-2">format_out_of_country_calling_number/2</a></td><td>Formats a phone number for out-of-country dialing purposes.</td></tr>
<tr><td valign="top"><a href="#format_out_of_country_keeping_alpha_chars-2">format_out_of_country_keeping_alpha_chars/2</a></td><td>Formats a phone number for out-of-country dialing purposes.</td></tr>
<tr><td valign="top"><a href="#get_country_code_for_region-1">get_country_code_for_region/1</a></td><td>Returns the country calling code for a specific region.</td></tr>
<tr><td valign="top"><a href="#get_country_mobile_token-1">get_country_mobile_token/1</a></td><td>Returns the mobile token for the provided country calling code if it has
  one, otherwise returns an empty string.</td></tr>
<tr><td valign="top"><a href="#get_example_number-1">get_example_number/1</a></td><td>Gets a valid fixed-line number for the specified region.</td></tr>
<tr><td valign="top"><a href="#get_example_number_for_non_geo_entity-1">get_example_number_for_non_geo_entity/1</a></td><td>Gets a valid number for the specified country calling code for a
  non-geographical entity.</td></tr>
<tr><td valign="top"><a href="#get_example_number_for_type-2">get_example_number_for_type/2</a></td><td>Gets a valid number of the specified type for the specified region.</td></tr>
<tr><td valign="top"><a href="#get_length_of_geograpical_area_code-1">get_length_of_geograpical_area_code/1</a></td><td> Gets the length of the geographical area code from the PhoneNumber object  
passed in, so that clients could use it to split a national significant  
number into geographical area code and subscriber number.</td></tr>
<tr><td valign="top"><a href="#get_length_of_national_destination_code-1">get_length_of_national_destination_code/1</a></td><td>Gets the length of the national destination code (NDC) from the PhoneNumber
  object passed in, so that clients could use it to split a national
  significant number into NDC and subscriber number.</td></tr>
<tr><td valign="top"><a href="#get_national_significant_number-1">get_national_significant_number/1</a></td><td>Gets the national significant number of a phone number.</td></tr>
<tr><td valign="top"><a href="#get_ndd_prefix_for_region-2">get_ndd_prefix_for_region/2</a></td><td>Returns the national dialling prefix for a specific region.</td></tr>
<tr><td valign="top"><a href="#get_number_type-1">get_number_type/1</a></td><td>Gets the type of a phone number.</td></tr>
<tr><td valign="top"><a href="#get_region_code_for_country_code-1">get_region_code_for_country_code/1</a></td><td>Returns the region code that matches the specific country code.</td></tr>
<tr><td valign="top"><a href="#get_region_code_for_number-1">get_region_code_for_number/1</a></td><td>Returns the region where a phone number is from.</td></tr>
<tr><td valign="top"><a href="#get_region_codes_for_country_calling_code-1">get_region_codes_for_country_calling_code/1</a></td><td>Populates a list with the region codes that match the specific country
  calling code.</td></tr>
<tr><td valign="top"><a href="#get_supported_regions-0">get_supported_regions/0</a></td><td>Convenience method to get a list of what regions the library has metadata
  for.</td></tr>
<tr><td valign="top"><a href="#hello-1">hello/1</a></td><td>TEST.</td></tr>
<tr><td valign="top"><a href="#is_alpha_number-1">is_alpha_number/1</a></td><td>Returns true if the number is a valid vanity (alpha) number such as 800
  MICROSOFT.</td></tr>
<tr><td valign="top"><a href="#is_nanpa_country-1">is_nanpa_country/1</a></td><td>Checks if this is a region under the North American Numbering Plan
  Administration (NANPA).</td></tr>
<tr><td valign="top"><a href="#is_number_match-2">is_number_match/2</a></td><td>Takes two phone numbers and compares them for equality.</td></tr>
<tr><td valign="top"><a href="#is_number_match_with_one_string-2">is_number_match_with_one_string/2</a></td><td>Takes two phone numbers and compares them for equality.</td></tr>
<tr><td valign="top"><a href="#is_number_match_with_two_strings-2">is_number_match_with_two_strings/2</a></td><td>Takes two phone numbers as strings and compares them for equality.</td></tr>
<tr><td valign="top"><a href="#is_possible_number-1">is_possible_number/1</a></td><td>Convenience wrapper around IsPossibleNumberWithReason.</td></tr>
<tr><td valign="top"><a href="#is_possible_number_for_string-2">is_possible_number_for_string/2</a></td><td>Checks whether a phone number is a possible number given a number in the  
form of a string, and the country where the number could be dialed from.</td></tr>
<tr><td valign="top"><a href="#is_possible_number_with_reason-1">is_possible_number_with_reason/1</a></td><td>Checks whether a phone number is a possible number.</td></tr>
<tr><td valign="top"><a href="#is_valid_number-1">is_valid_number/1</a></td><td>Tests whether a phone number matches a valid pattern.</td></tr>
<tr><td valign="top"><a href="#is_valid_number_for_region-2">is_valid_number_for_region/2</a></td><td>Tests whether a phone number is valid for a certain region.</td></tr>
<tr><td valign="top"><a href="#normalize_diallable_chars_only-1">normalize_diallable_chars_only/1</a></td><td>Normalizes a string of characters representing a phone number.</td></tr>
<tr><td valign="top"><a href="#normalize_digits_only-1">normalize_digits_only/1</a></td><td>Normalizes a string of characters representing a phone number.</td></tr>
<tr><td valign="top"><a href="#parse-2">parse/2</a></td><td>Parses a string and returns it in proto buffer format.</td></tr>
<tr><td valign="top"><a href="#parse_and_keep_raw_input-2">parse_and_keep_raw_input/2</a></td><td>Parses a string and returns it in proto buffer format.</td></tr>
<tr><td valign="top"><a href="#truncate_too_long_number-1">truncate_too_long_number/1</a></td><td>Attempts to extract a valid number from a phone number that is too long to
  be valid, and resets the PhoneNumber object passed in to that valid
  version.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="convert_alpha_characters_in_number-1">convert_alpha_characters_in_number/1</a></h3>
<div class="spec">
<p><tt>convert_alpha_characters_in_number(Number::binary()) -&gt; binary()</tt><br></p>
</div><p>Converts all alpha characters in a number to their respective digits on
  a keypad, but retains existing formatting.</p>

<h3 class="function"><a name="format-2">format/2</a></h3>
<div class="spec">
<p><tt>format(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, PhoneNumberFormat::<a href="#type-phonenumber_format">phonenumber_format()</a>) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p>Formats a phone number in the specified format using default rules. Note
  that this does not promise to produce a phone number that the user can
  dial from where they are - although we do format in either NATIONAL or
  INTERNATIONAL format depending on what the client asks for, we do not
  currently support a more abbreviated format, such as for users in the
  same area who could potentially dial the number without area code.</p>

<h3 class="function"><a name="format_by_pattern-3">format_by_pattern/3</a></h3>
<div class="spec">
<p><tt>format_by_pattern(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, PhoneNumberFormat::<a href="#type-phonenumber_format">phonenumber_format()</a>, UserDefinedFormats::[<a href="#type-phonenumber_format">phonenumber_format()</a>]) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p>TODO</p>

<h3 class="function"><a name="format_in_original_format-2">format_in_original_format/2</a></h3>
<div class="spec">
<p><tt>format_in_original_format(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, RegionCallingFrom::binary()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p>Formats a phone number using the original phone number format that the
  number is parsed from. The original format is embedded in the
  country_code_source field of the PhoneNumber object passed in. If such
  information is missing, the number will be formatted into the NATIONAL
  format by default. When the number is an invalid number, the method returns
  the raw input when it is available.</p>

<h3 class="function"><a name="format_national_number_with_carrier_code-2">format_national_number_with_carrier_code/2</a></h3>
<div class="spec">
<p><tt>format_national_number_with_carrier_code(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, CarrierCode::binary()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p>Formats a phone number in national format for dialing using the carrier as
  specified in the carrier_code. The carrier_code will always be used
  regardless of whether the phone number already has a preferred domestic
  carrier code stored. If carrier_code contains an empty string, return the
  number in national format without any carrier code.</p>

<h3 class="function"><a name="format_national_number_with_preferred_carrier_code-2">format_national_number_with_preferred_carrier_code/2</a></h3>
<div class="spec">
<p><tt>format_national_number_with_preferred_carrier_code(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, FallbackCarrierCode::binary()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p><p>Formats a phone number in national format for dialing using the carrier as  
specified in the preferred_domestic_carrier_code field of the PhoneNumber  
object passed in. If that is missing, use the fallback_carrier_code passed  
in instead. If there is no preferred_domestic_carrier_code, and the  
fallback_carrier_code contains an empty string, return the number in  
national format without any carrier code.</p>
 
  Use FormatNationalNumberWithCarrierCode instead if the carrier code passed
  in should take precedence over the number's preferred_domestic_carrier_code
  when formatting.</p>

<h3 class="function"><a name="format_number_for_mobile_dialing-3">format_number_for_mobile_dialing/3</a></h3>
<div class="spec">
<p><tt>format_number_for_mobile_dialing(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, RegionCallingFrom::binary(), WithFormatting::boolean()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p>Returns a number formatted in such a way that it can be dialed from a
  mobile phone in a specific region. If the number cannot be reached from
  the region (e.g. some countries block toll-free numbers from being called
  outside of the country), the method returns an empty string.</p>

<h3 class="function"><a name="format_out_of_country_calling_number-2">format_out_of_country_calling_number/2</a></h3>
<div class="spec">
<p><tt>format_out_of_country_calling_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, CallingFrom::binary()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p><p>Formats a phone number for out-of-country dialing purposes.</p>
 
  Note this function takes care of the case for calling inside of NANPA
  and between Russia and Kazakhstan (who share the same country calling
  code). In those cases, no international prefix is used. For regions which
  have multiple international prefixes, the number in its INTERNATIONAL
  format will be returned instead.</p>

<h3 class="function"><a name="format_out_of_country_keeping_alpha_chars-2">format_out_of_country_keeping_alpha_chars/2</a></h3>
<div class="spec">
<p><tt>format_out_of_country_keeping_alpha_chars(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, CallingFrom::binary()) -&gt; FormattedNumber::binary()</tt><br></p>
</div><p><p>Formats a phone number for out-of-country dialing purposes.</p>
 
  <p>Note that in this version, if the number was entered originally using alpha  
characters and this version of the number is stored in raw_input, this  
representation of the number will be used rather than the digit  
representation. Grouping information, as specified by characters such as  
"-" and " ", will be retained.</p>
 
  Caveats:
  1) This will not produce good results if the country calling code is both
  present in the raw input _and_ is the start of the national number. This
  is not a problem in the regions which typically use alpha numbers.
  2) This will also not produce good results if the raw input has any
  grouping information within the first three digits of the national number,
  and if the function needs to strip preceding digits/words in the raw input
  before these digits. Normally people group the first three digits together
  so this is not a huge problem - and will be fixed if it proves to be so.</p>

<h3 class="function"><a name="get_country_code_for_region-1">get_country_code_for_region/1</a></h3>
<div class="spec">
<p><tt>get_country_code_for_region(RegionCode::binary()) -&gt; CountryCode::non_neg_integer()</tt><br></p>
</div><p>Returns the country calling code for a specific region. For example,
  this would be 1 for the United States, and 64 for New Zealand.</p>

<h3 class="function"><a name="get_country_mobile_token-1">get_country_mobile_token/1</a></h3>
<div class="spec">
<p><tt>get_country_mobile_token(CountryCallingCode::non_neg_integer()) -&gt; binary()</tt><br></p>
</div><p>Returns the mobile token for the provided country calling code if it has
  one, otherwise returns an empty string. A mobile token is a number inserted
  before the area code when dialing a mobile number from that country from
  abroad.</p>

<h3 class="function"><a name="get_example_number-1">get_example_number/1</a></h3>
<div class="spec">
<p><tt>get_example_number(RegionCode::binary()) -&gt; ValidPhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, unknown_region}</tt><br></p>
</div><p>Gets a valid fixed-line number for the specified region. Returns {error, unknown_region} if
  the region was unknown, or the region 001 is passed in. For 001
  (representing non-geographical numbers), call
  GetExampleNumberForNonGeoEntity instead.</p>

<h3 class="function"><a name="get_example_number_for_non_geo_entity-1">get_example_number_for_non_geo_entity/1</a></h3>
<div class="spec">
<p><tt>get_example_number_for_non_geo_entity(CountryCallingCode::binary()) -&gt; ValidPhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, unknown_code}</tt><br></p>
</div><p>Gets a valid number for the specified country calling code for a
  non-geographical entity. Returns false if the metadata does not contain
  such information, or the country calling code passed in does not belong to
  a non-geographical entity.</p>

<h3 class="function"><a name="get_example_number_for_type-2">get_example_number_for_type/2</a></h3>
<div class="spec">
<p><tt>get_example_number_for_type(RegionCode::binary(), PhoneNumberType::<a href="#type-phonenumber_type">phonenumber_type()</a>) -&gt; ValidPhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, unknown_region}</tt><br></p>
</div><p>Gets a valid number of the specified type for the specified region.
  Returns false if the region was unknown or 001, or if no example number of
  that type could be found. For 001 (representing non-geographical numbers),
  call GetExampleNumberForNonGeoEntity instead.</p>

<h3 class="function"><a name="get_length_of_geograpical_area_code-1">get_length_of_geograpical_area_code/1</a></h3>
<div class="spec">
<p><tt>get_length_of_geograpical_area_code(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; non_neg_integer()</tt><br></p>
</div><p><p> Gets the length of the geographical area code from the PhoneNumber object  
passed in, so that clients could use it to split a national significant  
number into geographical area code and subscriber number. It works in such  
a way that the resultant subscriber number should be diallable, at least on  
some devices. An example of how this could be used:</p>
 
  <pre>  PhoneNumber = phonenumber_util.parse(&lt;&lt;"16502530000"&gt;&gt;,&lt;&lt;"US"&gt;&gt;),
  NationalSignificantNumber = phonenumber_util.get_national_significant_number(PhoneNumber),
  AreaCodeLength = phonenumber_util.get_lenth_of_geographical_area_code(PhoneNumber),
  {AreaCode, SubscriberNumber} = if
      AreaCodeLength &gt; 0 -&gt;
           {binary:part(NationalSignificantNumber, AreaCodeLength),
           binary:part(NationalSignificantNumber, AreaCodeLength, byte_size(NationalSignificantNumber))};
      true -&gt;
           {&lt;&lt;&gt;&gt;, NationalSignificatNumber}
  end.</pre>
 
  <p>N.B.: area code is a very ambiguous concept, so the authors generally  
recommend against using it for most purposes, but recommend using the  
more general national_number instead. Read the following carefully before  
deciding to use this method:</p>
 
   <p>- geographical area codes change over time, and this method honors those     
changes; therefore, it doesn't guarantee the stability of the result it     
produces.</p>
 
   <p>- subscriber numbers may not be diallable from all devices (notably mobile     
devices, which typically requires the full national_number to be dialled     
in most regions).</p>
 
   <p>- most non-geographical numbers have no area codes, including numbers     
from non-geographical entities.</p>
 
   - some geographical numbers have no area codes.</p>

<h3 class="function"><a name="get_length_of_national_destination_code-1">get_length_of_national_destination_code/1</a></h3>
<div class="spec">
<p><tt>get_length_of_national_destination_code(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; non_neg_integer()</tt><br></p>
</div><p>Gets the length of the national destination code (NDC) from the PhoneNumber
  object passed in, so that clients could use it to split a national
  significant number into NDC and subscriber number. The NDC of a phone
  number is normally the first group of digit(s) right after the country
  calling code when the number is formatted in the international format, if
  there is a subscriber number part that follows.
  <pre>  PhoneNumber = phonenumber_util:parse(&lt;&lt;"16502530000"&gt;&gt;, &lt;&lt;"US"&gt;&gt;),
  NationalSignificantNumber = phonenumber_util:get_national_significant_number(PhoneNumber),
  NationalDestinationCodeLength = phonenumber_util:get_length_of_national_destination_code(PhoneNumber),
  {NationalDestinationCode, SubscriberNumber} = if
      NationalDestinationCodeLength &gt; 0 -&gt;
          {binary:part(NationalSignificantNumber, NationalDestinationCodeLength),
          binary:part(NationalSignificantNumber, NationalDestinationCodeLength, byte_size(NationalSignificantNumber))};
      true -&gt;
      {&lt;&lt;&gt;&gt;, NationalSignificantNumber}
  end.</pre></p>

<h3 class="function"><a name="get_national_significant_number-1">get_national_significant_number/1</a></h3>
<div class="spec">
<p><tt>get_national_significant_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; NationalSignificantNum::binary()</tt><br></p>
</div><p>Gets the national significant number of a phone number. Note a national
  significant number doesn't contain a national prefix or any formatting.</p>

<h3 class="function"><a name="get_ndd_prefix_for_region-2">get_ndd_prefix_for_region/2</a></h3>
<div class="spec">
<p><tt>get_ndd_prefix_for_region(RegionCode::binary(), StripNonDigits::boolean()) -&gt; NationalPrefix::binary()</tt><br></p>
</div><p>Returns the national dialling prefix for a specific region. For example,
  this would be 1 for the United States, and 0 for New Zealand. Set
  strip_non_digits to true to strip symbols like "~" (which indicates a wait
  for a dialling tone) from the prefix returned. If no national prefix is
  present, we return an empty string.</p>

<h3 class="function"><a name="get_number_type-1">get_number_type/1</a></h3>
<div class="spec">
<p><tt>get_number_type(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; <a href="#type-phonenumber_type">phonenumber_type()</a></tt><br></p>
</div><p>Gets the type of a phone number.</p>

<h3 class="function"><a name="get_region_code_for_country_code-1">get_region_code_for_country_code/1</a></h3>
<div class="spec">
<p><tt>get_region_code_for_country_code(CountryCode::non_neg_integer()) -&gt; RegionCode::binary()</tt><br></p>
</div><p>Returns the region code that matches the specific country code. Note that
  it is possible that several regions share the same country calling code
  (e.g. US and Canada), and in that case, only one of the regions (normally
  the one with the largest population) is returned. If the
  countryCallingCode entered is valid but doesn't match a specific region
  (such as in the case of non-geographical calling codes like 800) the
  RegionCode 001 will be returned (corresponding to the value for World in
  the UN M.49 schema).</p>

<h3 class="function"><a name="get_region_code_for_number-1">get_region_code_for_number/1</a></h3>
<div class="spec">
<p><tt>get_region_code_for_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; RegionCode::binary()</tt><br></p>
</div><p>Returns the region where a phone number is from. This could be used for
  geo-coding at the region level.</p>

<h3 class="function"><a name="get_region_codes_for_country_calling_code-1">get_region_codes_for_country_calling_code/1</a></h3>
<div class="spec">
<p><tt>get_region_codes_for_country_calling_code(CountryCallingCode::non_neg_integer()) -&gt; [binary()]</tt><br></p>
</div><p>Populates a list with the region codes that match the specific country
  calling code. For non-geographical country calling codes, the region code
  001 is returned. Also, in the case of no region code being found, the list
  is left unchanged.</p>

<h3 class="function"><a name="get_supported_regions-0">get_supported_regions/0</a></h3>
<div class="spec">
<p><tt>get_supported_regions() -&gt; [binary()]</tt><br></p>
</div><p>Convenience method to get a list of what regions the library has metadata
  for.</p>

<h3 class="function"><a name="hello-1">hello/1</a></h3>
<div class="spec">
<p><tt>hello(X1) -&gt; any()</tt></p>
</div><p>TEST.</p>

<h3 class="function"><a name="is_alpha_number-1">is_alpha_number/1</a></h3>
<div class="spec">
<p><tt>is_alpha_number(Number::binary()) -&gt; boolean()</tt><br></p>
</div><p>Returns true if the number is a valid vanity (alpha) number such as 800
  MICROSOFT. A valid vanity number will start with at least 3 digits and will
  have three or more alpha characters. This does not do region-specific
  checks - to work out if this number is actually valid for a region, it
  should be parsed and methods such as IsPossibleNumberWithReason or
  IsValidNumber should be used.</p>

<h3 class="function"><a name="is_nanpa_country-1">is_nanpa_country/1</a></h3>
<div class="spec">
<p><tt>is_nanpa_country(RegionCode::binary()) -&gt; boolean()</tt><br></p>
</div><p>Checks if this is a region under the North American Numbering Plan
  Administration (NANPA).</p>

<h3 class="function"><a name="is_number_match-2">is_number_match/2</a></h3>
<div class="spec">
<p><tt>is_number_match(FirstNumber::<a href="#type-phonenumber">phonenumber()</a>, SecondNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; <a href="#type-match_type">match_type()</a></tt><br></p>
</div><p><p>Takes two phone numbers and compares them for equality.</p>
 
  Returns EXACT_MATCH if the country calling code, NSN, presence of a leading
  zero for Italian numbers and any extension present are the same.
  Returns NSN_MATCH if either or both has no country calling code specified,
  and the NSNs and extensions are the same.
  Returns SHORT_NSN_MATCH if either or both has no country calling code
  specified, or the country calling code specified is the same, and one NSN
  could be a shorter version of the other number. This includes the case
  where one has an extension specified, and the other does not.
  Returns NO_MATCH otherwise.
  For example, the numbers +1 345 657 1234 and 657 1234 are a
  SHORT_NSN_MATCH. The numbers +1 345 657 1234 and 345 657 are a NO_MATCH.</p>

<h3 class="function"><a name="is_number_match_with_one_string-2">is_number_match_with_one_string/2</a></h3>
<div class="spec">
<p><tt>is_number_match_with_one_string(FirstNumber::<a href="#type-phonenumber">phonenumber()</a>, SecondNumber::binary()) -&gt; <a href="#type-match_type">match_type()</a></tt><br></p>
</div><p>Takes two phone numbers and compares them for equality. This is a
  convenience wrapper for IsNumberMatch(PhoneNumber firstNumber,
  PhoneNumber secondNumber). No default region is known.
  Returns INVALID_NUMBER if second_number cannot be parsed into a phone
  number.</p>

<h3 class="function"><a name="is_number_match_with_two_strings-2">is_number_match_with_two_strings/2</a></h3>
<div class="spec">
<p><tt>is_number_match_with_two_strings(FirstNumber::binary(), SecondNumber::binary()) -&gt; <a href="#type-match_type">match_type()</a></tt><br></p>
</div><p>Takes two phone numbers as strings and compares them for equality. This
  is a convenience wrapper for IsNumberMatch(PhoneNumber firstNumber,
  PhoneNumber secondNumber). No default region is known.
  Returns INVALID_NUMBER if either number cannot be parsed into a phone
  number.</p>

<h3 class="function"><a name="is_possible_number-1">is_possible_number/1</a></h3>
<div class="spec">
<p><tt>is_possible_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; boolean()</tt><br></p>
</div><p>Convenience wrapper around IsPossibleNumberWithReason. Instead of returning
  the reason for failure, this method returns a boolean value.</p>

<h3 class="function"><a name="is_possible_number_for_string-2">is_possible_number_for_string/2</a></h3>
<div class="spec">
<p><tt>is_possible_number_for_string(Number::binary(), RegionDialingFrom::binary()) -&gt; boolean()</tt><br></p>
</div><p><p>Checks whether a phone number is a possible number given a number in the  
form of a string, and the country where the number could be dialed from.  
It provides a more lenient check than is_valid_number/1.  
See is_possible_number/1 for details.</p>
 
  <p>This method first parses the number, then invokes  
is_possible_number with the resultant PhoneNumber  
object.</p>
 
  region_dialing_from represents the region that we are expecting the number
  to be dialed from. Note this is different from the region where the number
  belongs. For example, the number +1 650 253 0000 is a number that belongs
  to US. When written in this form, it could be dialed from any region. When
  it is written as 00 1 650 253 0000, it could be dialed from any region
  which uses an international dialling prefix of 00. When it is written as
  650 253 0000, it could only be dialed from within the US, and when written
  as 253 0000, it could only be dialed from within a smaller area in the US
  (Mountain View, CA, to be more specific).</p>
<p><b>See also:</b> <a href="is_possible_number.html">is_possible_number</a>.</p>

<h3 class="function"><a name="is_possible_number_with_reason-1">is_possible_number_with_reason/1</a></h3>
<div class="spec">
<p><tt>is_possible_number_with_reason(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; ValidationResult::<a href="#type-validation_result">validation_result()</a></tt><br></p>
</div><p>Checks whether a phone number is a possible number. It provides a more
  lenient check than IsValidNumber() in the following sense:
    1. It only checks the length of phone numbers. In particular, it doesn't
       check starting digits of the number.
    2. It doesn't attempt to figure out the type of the number, but uses
       general rules which applies to all types of phone numbers in a
       region. Therefore, it is much faster than IsValidNumber().
    3. For fixed line numbers, many regions have the concept of area code,
       which together with subscriber number constitute the national
       significant number. It is sometimes okay to dial the subscriber
       number only when dialing in the same area. This function will return
       true if the subscriber-number-only version is passed in. On the other
       hand, because IsValidNumber() validates using information on both
       starting digits (for fixed line numbers, that would most likely be
       area codes) and length (obviously includes the length of area codes
       for fixed line numbers), it will return false for the
       subscriber-number-only version.</p>

<h3 class="function"><a name="is_valid_number-1">is_valid_number/1</a></h3>
<div class="spec">
<p><tt>is_valid_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; boolean()</tt><br></p>
</div><p>Tests whether a phone number matches a valid pattern. Note this doesn't
  verify the number is actually in use, which is impossible to tell by just
  looking at a number itself.</p>

<h3 class="function"><a name="is_valid_number_for_region-2">is_valid_number_for_region/2</a></h3>
<div class="spec">
<p><tt>is_valid_number_for_region(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>, Region::binary()) -&gt; boolean()</tt><br></p>
</div><p>Tests whether a phone number is valid for a certain region. Note this
  doesn't verify the number is actually in use, which is impossible to tell
  by just looking at a number itself. If the country calling code is not the
  same as the country calling code for the region, this immediately exits
  with false. After this, the specific number pattern rules for the region
  are examined.
  This is useful for determining for example whether a particular number is
  valid for Canada, rather than just a valid NANPA number.
  Warning: In most cases, you want to use IsValidNumber instead. For
  example, this method will mark numbers from British Crown dependencies
  such as the Isle of Man as invalid for the region "GB" (United Kingdom),
  since it has its own region code, "IM", which may be undesirable.</p>

<h3 class="function"><a name="normalize_diallable_chars_only-1">normalize_diallable_chars_only/1</a></h3>
<div class="spec">
<p><tt>normalize_diallable_chars_only(Number::binary()) -&gt; binary()</tt><br></p>
</div><p>Normalizes a string of characters representing a phone number. This strips
  all characters which are not diallable on a mobile phone keypad (including
  all non-ASCII digits).</p>

<h3 class="function"><a name="normalize_digits_only-1">normalize_digits_only/1</a></h3>
<div class="spec">
<p><tt>normalize_digits_only(Number::binary()) -&gt; binary()</tt><br></p>
</div><p>Normalizes a string of characters representing a phone number. This
  converts wide-ascii and arabic-indic numerals to European numerals, and
  strips punctuation and alpha characters.</p>

<h3 class="function"><a name="parse-2">parse/2</a></h3>
<div class="spec">
<p><tt>parse(NumberToParse::binary(), DefaultRegion::binary()) -&gt; PhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, term()}</tt><br></p>
</div><p><p>Parses a string and returns it in proto buffer format. This method will  
return an error like INVALID_COUNTRY_CODE if the number is not considered  
to be a possible number, and NO_PARSING_ERROR if it parsed correctly. Note  
that validation of whether the number is actually a valid number for a  
particular region is not performed. This can be done separately with  
IsValidNumber().</p>
 
  <p>number_to_parse can also be provided in RFC3966 format.</p>
 
  default_region represents the country that we are expecting the number to
  be from. This is only used if the number being parsed is not written in
  international format. The country_code for the number in this case would be
  stored as that of the default country supplied. If the number is guaranteed
  to start with a '+' followed by the country calling code, then
  "ZZ" can be supplied.</p>

<h3 class="function"><a name="parse_and_keep_raw_input-2">parse_and_keep_raw_input/2</a></h3>
<div class="spec">
<p><tt>parse_and_keep_raw_input(NumberToParse::binary(), DefaultRegion::binary()) -&gt; PhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, term()}</tt><br></p>
</div><p>Parses a string and returns it in proto buffer format. This method differs
  from parse/2 in that it always populates the raw_input field of the
  protocol buffer with number_to_parse as well as the country_code_source
  field.</p>

<h3 class="function"><a name="truncate_too_long_number-1">truncate_too_long_number/1</a></h3>
<div class="spec">
<p><tt>truncate_too_long_number(PhoneNumber::<a href="#type-phonenumber">phonenumber()</a>) -&gt; ValidPhoneNumber::<a href="#type-phonenumber">phonenumber()</a> | {error, no_valid_number}</tt><br></p>
</div><p>Attempts to extract a valid number from a phone number that is too long to
  be valid, and resets the PhoneNumber object passed in to that valid
  version. If no valid number could be extracted, the PhoneNumber object
  passed in will not be modified. It returns true if a valid phone number can
  be successfully extracted.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jan 13 2014, 13:26:23.</i></p>
</body>
</html>
